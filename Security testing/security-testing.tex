\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{fancyvrb}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  mathescape
}
\usepackage{minted}
\setlength\parindent{0pt}
\def\labelitemi{$\cdot$}
\newtheorem{remark}{Remark}
\author{Nicolò Fornari}
\title{Security testing}
\definecolor{mygray}{gray}{0.9}
\begin{document}
\maketitle
\section{Buffer Overflow}
\subsection{Stack and Heap}
The \emph{stack} is the memory set aside as scratch space for a thread of execution. When a function is called, a block is reserved on the top of the stack for local variables and some book keeping data. When that function returns, the block becomes unused and can be used the next time a function is called. The stack is always reserved in a LIFO (last in first out) order; the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack; freeing a block from the stack is nothing more than adjusting one pointer.\\\\
The \emph{heap} is memory set aside for dynamic allocation. Unlike the stack, there's no enforced pattern to the allocation and deallocation of blocks from the heap; you can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time; there are many custom heap allocators available to tune heap performance for different usage patterns.\\\\
Each thread gets a stack, while there's typically only one heap for the application (although it isn't uncommon to have multiple heaps for different types of allocation).\\\\
The OS allocates the stack for each system-level thread when the thread is created. Typically the OS is called by the language runtime to allocate the heap for the application.\\\\
\textbf{Scope:} the stack is attached to a thread, so when the thread exits the stack is reclaimed. The heap is typically allocated at application startup by the runtime, and is reclaimed when the application (technically process) exits.\\\\
\textbf{Size:} the size of the stack is set when a thread is created. The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system).\\\\
\textbf{Speed:} the stack is faster because the access pattern makes it trivial to allocate and deallocate memory from it (a pointer/integer is simply incremented or decremented), while the heap has much more complex bookkeeping involved in an allocation or free. Also, each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor's cache, making it very fast. Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe, i.e. each allocation and deallocation needs to be - typically - synchronized with "all" other heap accesses in the program.

\subsection{Fixing buffer overflow}
\begin{itemize}
\item Used counted versions of string functions (less performance but there is a boundary check)
\item Use safe string libraries, if available, or C++ strings (eg. fgets instead of gets,snprintf instead of printf)
\item Check loop termination and array boundaries
\item Use C++/STL containers instead of C arrays
\end{itemize}
\textbf{Non executable stack}\\
The OS kernel can be patched so as to forbid the execution of instructions whose address is on the stack.
\begin{itemize}
\item functions trampolines are addede to the stack by gcc for nested functions
\item signals handlers are allocated on the user stack by Linux
\item dynamically generated code may reside on the stack
\end{itemize}
\textbf{Canary words}\\
Canaries or canary words are known values that are placed between a buffer and control data on the stack to monitor buffer overflows. When the buffer overflows, the first data to be corrupted will usually be the canary, and a failed verification of the canary data is therefore an alert of an overflow, which can then be handled, for example, by invalidating the corrupted data.
\newpage
\section{String format}
\begin{minted}[frame=lines,
]{c}
#include<stdio.h>
int main(int argc,char* argv[]) {
	if (argc > 1)
		printf(argv[1]);
	return 0;
}
\end{minted}
\begin{itemize}
\item \%d \%d pops two integers in decimal format
\item \%c \%c pops two characters
\item \%p \%p pops to pointers in hexadecimal format
\item \%10\$d pops $10^{th}$ integer
\end{itemize}
\textbf{Problem.}the attacker can insert formatting instructions that pop (eg. \%s,\%x) or push (eg. \%n) values from/onto the call stack. This is possible if the formatting function has an undeclared number of parameters specified through ellipsis.\\\\
\textbf{Controls.} 
\begin{itemize}
\item Use constant strings as string formats
\item Sanitize user input
\item Use stream operator "$<<$" in C++ rather that functions of the \emph{printf} family
\end{itemize}
\section{Integer overflow}
\textbf{Problem.} an implicit or explicit integer type conversion produces unexpected results due to truncation or bit extension; integer operations overflow producing unexpected results.\\\\
\textbf{Controls:}
\begin{itemize}
\item Use unsigned integers if possible
\item Do not mix unsigned and signed integers in operations
\item Use large enough integer types
\item Check explicitly that expected boundaries are not exceeded
\end{itemize}
\newpage
\section{Injecton}
\subsection{SQL injection}
\textbf{Problem.} user provided data is used to form an SQL query (eg. through string concatenation) and the attacker provides malformed data aimed at changing the semantics of the query.\\
\textbf{Controls:} regular expressions, prepared statements, grant access to table only through stored procedures
\subsection{Command injection}
\textbf{Problem.} untrusted user data include commands as interpreter understands, forcing the interpreter to operate beyond its intended functions.\\
\textbf{Controls:}
\begin{itemize}
\item Deny-list: user data including characters ina deny list are rejected
\item Allow-list: only user data matching the character patterns in the allow list are interpreted
\item Quoting: user data transformed (eg. embedded with quotes) to avoid being interpreted as commands
\end{itemize}
\subsection{Error handling}
Example: the attacker provides an invalid file name hence a null pointer is used to perform file operations causing either DoS or disclosure of program and system's internals.\\
\textbf{Controls:}
\begin{itemize}
\item Handle error exceptions in the code
\item Never mask exceptions that may corrupt the program's state
\item Check function return values for errors
\end{itemize}
\subsection{XSS}
\textbf{Problem.} user input is directly displayed in an output webpage without any sanitization. the typical attack pattern is:
\begin{enumerate}
\item Identify a vulnerable website
\item Create a URL that submits malicious input
\item Social engineering to induce the victim to click on the URL
\item Victim clicks
\end{enumerate}
\textbf{Controls:} HTML encoding, sanitize user input
\section{Network}
\subsection{SSL and TLS}
\textbf{Problems:}
\begin{itemize}
\item The certificate authority signing the certificate is not validated
\item The signature of the certification authority is not validated for integrity
\item The time validity of the certificate is not checked
\item The certificate is not checked against the certificate revocation list.
\end{itemize}
While authentication checks are mandatory in the https protocol, if programmers use low level SSL/TLS libraries directly they might forget some important authentication check.
\subsection{DNS}
Scenario example: application performs automated software update connecting to a server. Solution: rely on SSL.
\section{Weak passwords}
\textbf{Problems:}
\begin{itemize}
\item Initial passsword is weak
\item Long passwords are not allowed
\item Short password are allowed
\item Dictionary passwords accepted
\item Alphanumeric-only passwords accepted
\item No checks on number of login attempts
\item User is locked out when too many login attempts are made (DoS)
\item user is not requested to change password periodically
\item Previous passwords are allowed when user changes password
\item No secure channel/protocol is used
\item Change passwords are not reauthenticated
\item Passwords can be reset upon end user request based on weak information
\item Reset passwords are specified by the user rather than being delivered securely
\item Default password change is not enforced on first login
\item Passwords are stored in clear
\item Login failure messages and response time reveal sensitive information
\item Upon login failure wrong passwords are logged
\end{itemize}
\textbf{Controls:}
\begin{itemize}
\item Use PBKDF2 to hash passwords
\item Iterate password hashing to increase response time
\item Raise barriers to password reset (questions, secure delivery,extra authentication)
\item Instead of locking out users let them retry after some time has passed
\item Increase the response time when login failures occur
\item Blacklist IP addresses (and alert the user) if too many login attempts occur
\item Multifactor authentication: password + token
\end{itemize}
\section{Data storage}
Wrong read/write permissions (eg. world writable)
\begin{itemize}
\item Executable
\item Configuration files
\item DB files
\end{itemize}
Sensitive data is hardcoded: an attacker having access to it can easily perform reverse engineering.\\
Example: /home/apache/config instead of www/html\\
Remark: scrub the memory once secret data is no longer needed.
\subsection{Information leakage}
\begin{itemize}
\item \textbf{Time:} time measures can leak information (eg. first letter of password right/wrong)
\item \textbf{Error messages:} user name correctness,version information, network addresses,reason for failure, path information
\item \textbf{Stack information:} reported to the user when a function is called with less parameters than expected
\end{itemize}
\section{Access}
\begin{itemize}
\item Race conditions
Problem. The same files are accessed by different applications. Since the file is accessed by name and not by \emph{handle} it is not locked!
\item Fake files
If the attacker provides a device name the process remains stuck until the device times out (DoS)
\item traversal
\end{itemize}
Controls:
\begin{itemize}
\item Never use a file name for more than one operation. Use a file handle instead
\item Keep applications files in a safe directory
\item Resolve the path before validating
\item Lock files explicitly when first accessed
\item If a file has zero size truncate it to avoid replacement
\item Check if a file happens to be a device,symbolic link or a pièe
\end{itemize}
\section{Race conditions}
The application is crashed by concurrent code that is allowed to access data not protected through mutual exclusion.
\begin{itemize}
\item Time of check (TOC) and Time of use (TOU) should be within a protected time interval.
\item Use locks/mutual exclusion (synchronized)
\item Write reentrant code
\item Use private stores for temporary files and directories
\end{itemize}
\section{Random numbers}
\begin{itemize}
\item PRNG: used for statistical simulation, given the seed the sequence is totally predictable
\item CRNG (Cryptographic pseduo random number generator): the seed is unguessable
\item TRNG (True prng): eg. timestamps of unpredictable events (eg. mouse movements), still they are used just as seeds since they may contain some statistical bias
\end{itemize}
\section{Usability}
Security information is communicated, collected or made modifiable through an interface having quite poor usability.\\
Problem. user select the easy (usually unsecure) answer, without paying attention.\\
Controls:
\begin{itemize}
\item Make security decisions for users whenever possible
\item Treat certification problems as server being inaccessible
\item Adopt progressive disclosure
\item Clearly indicate consequences
\item State password requirements explicitly
\item Hide dangerous security options in deeply nested menus
\end{itemize}
\newpage
\section{Flow analysis}
Flow analysis is a general static analysis framework that can be instantiated in several specific code analyses, among which taint analysis.\\
We can represent a program as a control flow graph. We propagate flow information until a fixed point is reached.\\\\
\textbf{Control flow graph:} $CFG = (N,E,n_e,n_x)$\\
N is a node set. E is the edge set $E \subset N \times N$. $n_e$ entry node, $n_x$ exit node.\\
For conditional statements there will be two successors. The same for loops.
\begin{minted}[frame=lines,linenos
]{php}
<?php $xx = explode(";",$_POST["x"]);
$s = $_POST["y"];
foreach ($xx as $x) {
	$s = " " . $s;
	if (htmlentities($x) == $x)
		$s .= $x;	 }
echo $s;
?>
\end{minted}
\begin{center}
\includegraphics[scale=0.5]{img/g1.jpg}
\end{center}
\textbf{Flow analysis framework}
\begin{itemize}
\item Flow information: set $V$, it is the flow information propagated in the CFG, assigned to $IN[n]$ and $OUT[n]$
\item Transfer function: $f_n(x): V \to V \hspace{2em} OUT[n]= f_n(IN[n])$
\item Confluence (meet) operator $\wedge$: join flow values coming from the OUT of the predecessors (or successors) of current node n\\
$ IN[n] = \wedge_{p \in pred(n)}OUT[p]$
\item Direction of propagation: forward (look at predecessors) or backward (look at successors)
\end{itemize}
\textbf{Example of inputs:} set of values or booleans. For sets we can use union and intersection for the meet operator while for booleans we can use the logical and.\\\\
\textbf{Assumptions:}
\begin{itemize}
\item Identity is a valid transfer function: $OUT[n] = IN[n]$
\item We can replace two nodes with the composition of the two transfer functions $f,g$.
\item $\wedge$ is associative,commutative and idempotent ($x \wedge x = x$)
\item Top element: $\exists T \in V,T \wedge x = x$
\item Transfer function is monotonic. Note that $x \leq y$ means $x \wedge y = x$
\end{itemize}
\textbf{Flow analysis algorithm}
\begin{lstlisting}[frame=lines]
for each node $n$
	$IN[n] = T$
	$OUT[n] = f_n(IN[n])$
end for

while any $IN[n]$ or $OUT[n]$ changes across iteration
	for each node $n$
		$IN[n] = \wedge_{p \in pred(n)}OUT[p]$
		$OUT[n] = f_n(IN[n])$
	end for
end while
\end{lstlisting}
\textbf{Def} bottom $\perp$ st. $\perp \leq x \forall x$\\\\
\textbf{Examples of Flow analysis:}
\begin{itemize}
\item Taint analysis
\item Reaching definitions and reachable users
\item Dominators and postdominators
\item Constant propagation
\item Pointer analysis
\end{itemize}
% 		CONVERGENCE --------------------------------
%
%If a bottom element exists convergence descends from monotonicity. If $V$ is finite then $\perp$ exists.\\\\
%
%
%\textbf{Meet over path}\\
%$MOP[n] = \bigwedge_{p\in P_n}f_p(T)$ where $P_n$ are all the paths leading to node $n$.\\Note: if there are loops then $P_n$ is an infinite set.\\
%Example: see slide n 13\\\\
%\textbf{Def.} Exact solution $EX[n] = \bigwedge_{p \in feas(P_n)}f_p(T)$\\
%\textbf{conservativity}\\
%All possible executions are taken into account. The weakness is that there might be some extra values which do not belong to any solutions (false alarms). 
%$$ EX[n] \geq MOP[n] \geq FA[n]$$
%when transfer functions are distributive  flow analysis produces the MOP solution:
%$$ f_n(x \wedge y) = f_n(x) \wedge f_n(y) \implies MOP[n] = FA[n] $$
%\section{Interprocedural}
%To avoid loops in graph you introduce \emph{call nodes}.
%This new representation presents an issue: there are also unrealizable paths.
%\textbf{Def. Realizable path}
%\begin{itemize}
%\item p is empty
%\item The first return node is immediately preceded by a matching call node and the path obtained after removing these nodes is in turn realizable.
%\end{itemize}
%\begin{remark}
%Note that unfeasible and unrealizable paths are different.
%Example of unfeasible: if we have mutually exclusive conditions it will be impossible to have a path in which both conditions are true.
%The latter violates the matching between call and return
%\end{remark}
%
% --------------------------------------
\newpage
\subsection{Call string method}
Flow information $x$ is propagated together with the associated call string: $(x,CS)$
\begin{center}
\includegraphics[scale=0.5]{img/g2.jpg}
\end{center}
\textbf{Example 1:} $IN[6] = (x_1,C2),(x_3,C4)$\\\\
\textbf{Example 2:} The meet operator is applied only when call strings are identical.\\\\
$OUT[6] = (y_1,C2),(y_2,C_4)$\\
$OUT[7] = (z_1,C2),(z_2,C4)$\\
$IN[8] = OUT[6] \wedge OUT[7] = (y_1 \wedge z_1,C2),(y_2 \wedge z_2,C4)$\\\\
At return nodes, flow information is propagateed only to call nodes matching the last element of the call string, which is removed.
\subsection{Functional method}
A summary transfer function $\phi_P$ is computed for each procedure $P$ and is used at each node where $P$ is called. the summary transfer functions $\phi_P$ are known in closed form when $\wedge = \cup$ and transfer function $f_n$ have the following structure:
$$ f_n(x) = GEN[n] \cup (x \setminus KILL[n])$$
\newpage
\subsection{Taint analysis}
Taint analysis aims at keeping track of tainted variables along the execution paths:
\begin{itemize}
\item {\bf Static taint analysis:} a flow analysis conducted on the CFG providing conservative results
\item {\bf Dynamic taint analysis:} the taint status of variables is updated at run time and execution is interrupted if a tainted variable is used at a security critical statement.
\end{itemize}
The \emph{taint status} of a variable is true if the variable may contain unsanitized user input, false if it is ensured not to contain it.\\\\
Flow  information propagated for taint analysis consists of taint sets, formally $V = \mathcal{P}(X)$, where $X$ is the set of all program variables.\\\\
At a join point a variable is tainted if its status is tainted in any of the incoming edges. As a consequence the meet operator is union, so
\begin{itemize}
\item Top is the empty set: $T \wedge x = x \forall x$
\item Monotonically decreasing flow values correspond to increasingly larger taint sets
\item Bottom is $X$
\end{itemize}
The transfer function for taint analysis has the form:
$$ f_n(x) = GEN[n] \cup (x \setminus KILL[n])$$
$GEN[n] = \{ x | x $ is assigned an input value at statement $n \} \cup \{ x | \exists y: x$ is assigned a value obtained from $y \wedge y \to T\}$\\\\
$KILL[n] = \{x|x$ is sanitized by statement $n \} \cup \{ x| \forall y: x $ is assigned a value obtained from $y \wedge y \to F \}$\\\\

\textbf{Taint analysis algorithm}
\begin{lstlisting}[frame=lines]
for each node $n$
	$IN[n] = \{\}$
	$OUT[n] = GEN[n]$
end for

while any $IN[n]$ or $OUT[n]$ changes across iteration
	for each node $n$
		$IN[n] = \cup_{p \in pred(n)}OUT[p]$
		$OUT[n] = GEN[n] \cup (IN[n] \ KILL[n])$
	end for
end while
\end{lstlisting}
\newpage
\section{Penetration testing}
Type of pentetration tests:
\begin{enumerate}
\item Authentication
\item Session Management
\item Input Manipulation
\item Output Manipulation
\item Information Leakage
\end{enumerate}
\textbf{Authentication}
\begin{itemize}
\item Brute force and or heuristics to guess the password
\item Bypass authentication using a spoofed token
\item Replay auth info eavesdropped on the network
\end{itemize} 
Prerequisites: determine the maximum login attempts allowed, the login/idle timeout, acquire user information\\\\
\textbf{Session management}
\begin{itemize}
\item Hijack the session of another user and gather data or submit excessive or invalid input
\item Replay submissions made by another user
\item Submit direct URL requests with heuristically guessed session IDs
\end{itemize}
Prerequisites: determine the maximum number of concurrent sessions, identify cookie,hidden fields or URL parameters used for session management.\\\\
\textbf{Input manipulation}\\
\begin{itemize}
\item Use exceptionally long character sequences for inputs of string type
\item Injectio system commands
\item Inject javascript or server side include code
\item Use URL or UNICODE encoding to perform sys/SQL/JS/SSI injection
\item Provide unauthorized paths with inputs requiring a file or directory
\item Modify cookies or hidden fields or http header
\item Provide invalid input to trigger the execution of error code
\end{itemize}
Prerequisites: determine the limitations on input variable length, protocol messages, data types and formats.\\\\
\textbf{Output manipulation}
\begin{itemize}
\item Retrieve and manipulate cookies or hidden fields
\item Retrieve and manipulate cached information, serialized objects
\item Modifiy information stored in temporary files
\end{itemize}
Prerequistes: identify where the application output is stored on the client side\\\\
\textbf{Information leakage}
\begin{itemize}
\item Find useful information in html code
\item Examine messagges to obtain information about the internals of the application
\end{itemize}
Prerequistes: make assumptions about the technologies and programming environment used to develop the application.
\newpage
\section{Whitebox fuzzing}
\textbf{Def. blackbox fuzzing:} to trigger a bug, such as buffer overflow, by randomly mutating well formed program inputs\\\\
\textbf{Def. whitebox fuzzing:} to execute all feasible paths by means of symbolic execution
\subsection{Symbolic execution}
\textbf{Def. symbolic execution:} is a means of analyzing a program to determine what inputs cause each part of a program to execute. An interpreter follows the program, assuming symbolic values for inputs rather than obtaining actual inputs as normal execution of the program would.
\begin{minted}[frame=lines,
]{c}
int testme(int x) {
	int y = x+3;
	if (y==13)
		abort();
	return 0;		
}
\end{minted}
\begin{center}
\begin{tabular}{|c|c|}
\hline 
Concrete state & Symbolic state \\ 
\hline 
$x=0$ & $x=x_0$ \\ 
\hline 
$y=3$ & $y=x_0+3$ \\ 
\hline 
\end{tabular} 
\end{center}
\begin{enumerate}
\item Execute a random test case
\item Collect symbolic constraints along the concretely executed path
\item Negate one or more branch condition in the path constraint
\item Use a constraint solver to generate a new test input for the negated constraint
\item Execute a new test cae, covering a new path. Iterate from 2.
\end{enumerate}
\textbf{Problem.} the constraint solver may not be powerful enough to determine concrete values that satisfy the negated path constraint. If necessary some constraints must be replaced with concrete values. In particular semplification may be necessary whenever non linear constraints  are involved or black box external functions are called.\\\\
\textbf{Properties}
\begin{itemize}
\item Incompleteness: dynamic symbolic execution is complete only if the constraint solver can successfully solve all constraints without semplification
\item Approximation: an input satisfying a simplified path condition is not ensured to execute the path of interest (divergence)
\item Soundness: since generated tests are executable revealed faults are real faults
\end{itemize}
\textbf{Runtime error:} the condition that produces a run time error (eg. array out of bound, division by zero) is added to the path condition and a solution is searched\\\\
\textbf{Assertions:} negated assertions are added to the path condition
\end{document}
